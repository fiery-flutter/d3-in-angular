// keyof type discriminator should match type on parse

/**
 *
 * @see {isDiagram} ts-auto-guard:type-guard
 */
 export interface Diagram {
    type: "Diagram";
    /**
     *
     * Could enforce generics of certain diagram types
     * But abstraction for something like this adds more complexity than it solves
     * Make specific ERD model first then look at a generic diagram model if it adds value
     */
    diagramType: ERDiagramType;
    id: string;
    accountID: string;
    projectID: string;
    name: string;
    /**
     * Base form is essentially positions.
     *
     * The shapes themselves are predefined
     *
     * May come into issues if we want to extend to larger diagramming functionality (out of scope)
     *
     *
     * i.e. hitbox, collision detection can be somehwat predefined with our typed shapes of a limited selection.
     */
    shapes: ChartPositionedShape;
    createdAt: number;
    updatedAt: number;
}

/**
 * @see {ConceptualErd} ts-auto-guard:type-guard
 */
export interface ConceptualErd
    extends Omit<Diagram, "type" | "diagramType" | "shapes"> {
    type: "ConceptualErd";
    diagramType: ERDiagramType.conceptual;

    entities: Entity[];
    relationships: Relationship[];
}

/**
 *
 */
export enum ERDiagramType {
    conceptual = "conceptual",

    /**
     * Logical enmeshed together with physical rip
     * physical logical physiological
     *
     * Start adding the somewhat-physical data types here
     *
     *
     */
    logical = "logical",

    /**
     * We should not have a diagram for this
     *
     * Purely generated by SQL export from the json
     */
    physical = "physical",
}

// Try from a Relationship-first design view rather than a diagramming-first shapes linking viewpoint
// Automate positioning as much as possible
// Though likely lose stability between updates i.e. if first entity is in top left
// and we add an entity... d3-force positioning may re-layout everything to move it to the bottom.

/**
 * Index accommodation?
 *
 * Ostensibly to make NoSQL Firestore-like databases easier to use
 *
 *
 * an indexed relationships collection
 *
 * Rather than nesting potentially large entity+attributes under a relationship object
 *
 * To support collection paradigm rather than large nested inflexible documents
 * @see {isRelationship} ts-auto-guard:type-guard
 */
export interface Relationship extends ChartPositionedShape {
    type: "Relationship";
    /**
     * Conform to a loose convention: verb noun
     *
     */
    relationshipName: string;
    firstEntityID: string;
    secondEntityID: string;
}

/**
 * Simplified MVP model
 *
 * Associative relationship
 *
 *
 * Not using an unbounded infinite N-ary relationship model due to complexity of both user modelling and technicalitiies
 *
 * @see {isTernaryRelationship} ts-auto-guard:type-guard
 */
export interface TernaryRelationship extends Omit<Relationship, "type"> {
    type: "TernaryRelationship";

    thirdEntityID: string;
}

/**
 * Entity, Attribute, Relationship
 *
 * the Relationship itself could also have a position; however,
 * the linker line between each entity to the relationship diamond node should be automatically drawn
 * @see {isChartPositionedShape} ts-auto-guard:type-guard
 */
export interface ChartPositionedShape {
    x: number;
    y: number;
}
/**
 *
 * @see {isEntity} ts-auto-guard:type-guard
 */
export interface Entity extends ChartPositionedShape {
    type: "Entity";
    id: string;
    name: string;
    attributes: Attribute[];
}

/**
 * Conceptual entity attribute
 * @see {isAttribute} ts-auto-guard:type-guard
 */
export interface Attribute extends ChartPositionedShape {
    type: "Attribute";
    id: string;

    attributeName: string;

    isPartOfPrimaryKey: boolean;

    isOptional: boolean;

    isUnique: boolean;

    /**
     * No types until physical or maybe logical model relational schema
     */
    /* attributeType:  */
}

/**
 * Depends on a cross-section of standard types
 */
export type AttributeType = "boolean" | "text" | "int" | "numeric" | "money" | "timestamptz" | "uuid"
