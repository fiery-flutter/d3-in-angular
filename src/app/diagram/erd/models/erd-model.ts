// keyof type discriminator should match type on parse

/**
 *
 * @see {isDiagram} ts-auto-guard:type-guard
 */
export interface Diagram {
    type: "Diagram";
    /**
     *
     * Could enforce generics of certain diagram types
     * But abstraction for something like this adds more complexity than it solves
     * Make specific ERD model first then look at a generic diagram model if it adds value
     */
    diagramType: ERDiagramType;
    id: string;
    accountID: string;
    projectID: string;
    name: string;
    /**
     * Base form is essentially positions.
     *
     * The shapes themselves are predefined
     *
     * May come into issues if we want to extend to larger diagramming functionality (out of scope)
     *
     *
     * i.e. hitbox, collision detection can be somehwat predefined with our typed shapes of a limited selection.
     */
    shapes: ChartPositionedShape;
    createdAt: number;
    updatedAt: number;
}

/**
 * @see {ConceptualErd} ts-auto-guard:type-guard
 */
export interface ConceptualErd
    extends Omit<Diagram, "type" | "diagramType" | "shapes"> {
    type: "ConceptualErd";
    diagramType: ERDiagramType.conceptual;

    entities: Entity[];
    relationships: Relationship[];
}

/**
 *
 */
export enum ERDiagramType {
    conceptual = "conceptual",

    /**
     * Logical enmeshed together with physical rip
     * physical logical physiological
     *
     * Start adding the somewhat-physical data types here
     *
     *
     */
    logical = "logical",

    /**
     * We should not have a diagram for this
     *
     * Purely generated by SQL export from the json
     */
    physical = "physical",
}

/**
 * Not much more value to enforce specific numbers..
 * 
 * Design-wise.
 * 
 * Embedded contextual information is good, though, rather than allowing people to 
 * place free-text labels everywhere
 */
export type CardinalityType =

    // Optional - Crows-foot notation
    // "zero" |
    // Mandatory - Crows-foot notation
    "one" |
    // Mandatory - Crows-foot notation
    "many";

// export interface Cardinality {
//     /**
//      * Minimum must be zero or one
//      * zero = optional
//      * one = mandatory
//      */
//     min: Omit<CardinalityType, "many">;
//     /** Maximum must be one or many */
//     max: CardinalityType
// }

/**
 * 
 * * i.e. A to B 0..1 is optional
 * * i.e. A to B 1..1 is mandatory or 1..N
 * * A to B 1:N is mandatory 
 * 
 * 
 */
export type Participation = "optional" | "mandatory";

export interface Shape {

    // Some predefined styling?
    // Or go directly to SCSS classes
    // or canvas

    // i.e. Colour = red for any entity that is not currently linked
}

// Try from a Relationship-first design view rather than a diagramming-first shapes linking viewpoint
// Automate positioning as much as possible
// Though likely lose stability between updates i.e. if first entity is in top left
// and we add an entity... d3-force positioning may re-layout everything to move it to the bottom.

/**
 * Index accommodation?
 *
 * Ostensibly to make NoSQL Firestore-like databases easier to use
 *
 *
 * an indexed relationships collection
 *
 * Rather than nesting potentially large entity+attributes under a relationship object
 *
 * To support collection paradigm rather than large nested inflexible documents
 * @see {isRelationship} ts-auto-guard:type-guard
 */
export interface Relationship extends ChartPositionedShape {
    type: "Relationship";
    /**
     * Conform to a loose convention: verb noun
     *
     */
    relationshipName: string;
    firstEntityID: string;
    secondEntityID: string;

    firstLinkParticipation: Participation
    firstLinkCardinality: CardinalityType;

    /**
     * May be redundant to break out the config details into the connectors?
     * 
     * Identifying relationship side for the double line mandatory only when
     * the other side is a weak entity
     * 
     * Hard to absolutely model like this without some logical enforcement
     * 
     */
    /* firstLinkIsStrongIdentifying: boolean; */
    /**
     * Only one out of the binary links can be weak
     * and the other must be strong identifying by deduction.
     * 
     * First entity existence is dependent entirely on the other entity 
     * i.e. it would need to draw its primary key from the strong entity
     * 
     * 
     * This would make the second link a double line and the diamond a double line
     */
    firstLinkisWeak: boolean;

    secondLinkParticipation: Participation;

    secondLinkCardinality: CardinalityType;

    /**
     * Redundancy duplication poor data model
     * 
     * identifying/weak we restrict to only make sense in a binary relationship...
     */
    /* secondLinkIsStrongIdentifying: boolean; */
    /**
     * Only one can be weak
     * 
     * Could alternately standardise a convention that:
     * if first link is weak = false then second link is weak
     * if first link is weak = true then second link is strong
     * if first link is null or missing then it is a regular link
     * 
     * 
     * In the current form, both need to be specified.
     */
    secondLinkIsWeak: boolean;







}



/**
 * Simplified MVP model
 *
 * Associative relationship
 *
 *
 * Not using an unbounded infinite N-ary relationship model due to complexity of both user modelling and technicalitiies
 *
 * @see {isTernaryRelationship} ts-auto-guard:type-guard
 */
export interface TernaryRelationship extends Omit<Relationship, "type"> {
    type: "TernaryRelationship";

    thirdEntityID: string;

    thirdLinkIsIdentifying: boolean;
}

/**
 * Entity, Attribute, Relationship
 *
 * the Relationship itself could also have a position; however,
 * the linker line between each entity to the relationship diamond node should be automatically drawn
 * @see {isChartPositionedShape} ts-auto-guard:type-guard
 */
export interface ChartPositionedShape {
    x: number;
    y: number;
}
/**
 *
 * @see {isEntity} ts-auto-guard:type-guard
 */
export interface Entity extends ChartPositionedShape {
    type: "Entity";
    id: string;
    name: string;
    attributes: Attribute[];
}

/**
 * Conceptual entity attribute
 * @see {isAttribute} ts-auto-guard:type-guard
 */
export interface Attribute extends ChartPositionedShape {
    type: "Attribute";
    id: string;

    attributeName: string;

    /**
     * should really assume at the conceptual level 3NF style
     * 
     * If it is unique and normalised,
     * then the unique part should be the only unique part?
     * 
     * think about the theory candidate functional superset of itself
     * 
     * 
     * This probably does not belong in the conceptual ERD attribute model
     */
    isPartOfPrimaryKey: boolean;

    isOptional: boolean;

    isUnique: boolean;

    /**
     * Affects presentation and does not exist in the logical or physical layers
     * 
     * 
     */
    isDerivedCalculated: boolean;
    /**
     * No types until physical or maybe logical model relational schema
     */
    /* attributeType:  */
}

/**
 * Depends on a cross-section of standard types
 */
export type AttributeType = "boolean" | "text" | "int" | "numeric" | "money" | "timestamptz" | "uuid"
