export function getChallenge1BinaryGap(input: number) {
  // We should check that input is a positive integer before proceeding
  // Do some operation to resolve the largest number of consecutive binary zeroes (get binary representation of the positive integer number)
  // ? Do we need to lok at intricacies unsigned vs signed integer dependent on the language.


  return 0;
}

/**
 * Check not NaN
 *
 */
function isNumber() {
  return false;
}
/**
 * Inclusive range >= greater than or equal to 1.
 *
 * An integer
 * Not zero
 * Not negative
 *
 */
function isPositiveInteger() {
  return false;
}

/**
 * Assuming the input they give can fit outside the range and does not wrap around overflow...
 */
function isSizeWithinRange() {
  return false;
}

function getBinaryRepresentation() {
  // Unless there is a faster native shift operator in js ?
  // Maybe bit xor or hamming code like operation can solve quickly.

}
